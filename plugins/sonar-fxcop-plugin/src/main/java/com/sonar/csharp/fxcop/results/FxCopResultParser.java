/*
 * Copyright (C) 2010 SonarSource SA
 * All rights reserved
 * mailto:contact AT sonarsource DOT com
 */

/*
 * Created on Sep 24, 2009
 */
package com.sonar.csharp.fxcop.results;

import java.io.File;
import java.text.ParseException;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.batch.SensorContext;
import org.sonar.api.profiles.RulesProfile;
import org.sonar.api.resources.Project;
import org.sonar.api.resources.Resource;
import org.sonar.api.rules.ActiveRule;
import org.sonar.api.rules.Rule;
import org.sonar.api.rules.RuleFinder;
import org.sonar.api.rules.RuleQuery;
import org.sonar.api.rules.Violation;
import org.sonar.api.utils.ParsingUtils;
import org.w3c.dom.Element;

import com.sonar.csharp.fxcop.Constants;

/**
 * Parses the reports generated by a FXCop analysis.
 */
public class FxCopResultParser extends AbstractXmlParser {

  private final static Logger log = LoggerFactory.getLogger(FxCopResultParser.class);

  private final Project project;
  private final SensorContext context;
  private final RuleFinder ruleFinder;
  private final RulesProfile profile;

  /**
   * Constructs a @link{FxCopResultParser}.
   * 
   * @param project
   * @param context
   * @param rulesManager
   * @param profile
   */
  public FxCopResultParser(Project project, SensorContext context, RuleFinder ruleFinder, RulesProfile profile) {
    super();
    this.project = project;
    this.context = context;
    this.ruleFinder = ruleFinder;
    this.profile = profile;
  }

  /**
   * Parses a processed violation file.
   * 
   * @param stream
   */
  public void parse(File file) {
    List<Element> issues = extractElements(file, "/issues/issue");
    // We add each issue
    for (Element issueElement : issues) {
      String path = getNodeContent(issueElement, "path");
      String fileName = getNodeContent(issueElement, "name");
      String key = getNodeContent(issueElement, "key");
      String message = getNodeContent(issueElement, "message");
      String lineNumber = getNodeContent(issueElement, "line");

      final Resource<?> resource;
      if (StringUtils.isBlank(fileName) || StringUtils.isBlank(path)) {
        log.debug("violation without file path");
        resource = null;
      } else {
        resource = org.sonar.api.resources.File.fromIOFile(new File(path, fileName), project);
        if (resource == null) {
          log.debug("violation on an excluded file {}", file);
          continue;
        }
      }

      Integer line = getIntValue(lineNumber);
      Rule rule = ruleFinder.find(RuleQuery.create().withRepositoryKey(Constants.REPOSITORY_KEY).withKey(key));
      if (rule == null) {
        // We skip the rules that were not registered
        log.debug("violation found for an unknown '{}' rule", key);
        continue;
      }
      ActiveRule activeRule = profile.getActiveRule(Constants.PLUGIN_KEY, key);
      Violation violation = Violation.create(activeRule, resource);
      violation.setLineId(line);
      violation.setMessage(message);
      if (activeRule != null) {
        violation.setSeverity(activeRule.getSeverity());
      }

      // We store the violation
      context.saveViolation(violation);
    }
  }

  /**
   * Extracts the line number.
   * 
   * @param lineStr
   * @return
   */
  protected Integer getIntValue(String lineStr) {
    if (StringUtils.isBlank(lineStr)) {
      return null;
    }
    try {
      return (int) ParsingUtils.parseNumber(lineStr);
    } catch (ParseException ignore) {
      return null;
    }
  }
}
